# Comprehensive Audit Logging Implementation Plan

**Document Version:** 1.0  
**Date:** October 24, 2025  
**Status:** Planning Phase  
**Scope:** All state-changing operations across the OpenID Provider

---

## Table of Contents

- [Executive Summary](#executive-summary)
- [What to Audit](#what-to-audit)
- [Audit Event Model](#audit-event-model)
- [Storage Architecture](#storage-architecture)
- [Implementation Tasks](#implementation-tasks)
- [Admin UI Integration](#admin-ui-integration)
- [Performance Considerations](#performance-considerations)
- [Security & Compliance](#security--compliance)

---

## Executive Summary

This document outlines the plan to implement **comprehensive audit logging** for the OpenID Provider. Every operation that creates, modifies, or deletes system data will be logged to a dedicated audit store, providing complete traceability for security, compliance, and debugging purposes.

**Key Features:**
- Audit all state-changing operations (Create, Update, Delete)
- Separate audit storage (JSON or MongoDB)
- Admin UI for viewing and filtering audit logs
- Tamper-resistant audit trail
- Performance-optimized async logging
- Compliance-ready (GDPR, SOC 2, ISO 27001)

**Estimated Effort:** 6-8 days

---

## What to Audit

### Categories of Auditable Events

#### 1. User Management Operations
**Priority:** 🔴 Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| User Created | `user.created` | User ID, username, email, role, created by |
| User Updated | `user.updated` | User ID, changed fields, old values, new values, updated by |
| User Deleted | `user.deleted` | User ID, username, email, deleted by |
| User Password Changed | `user.password_changed` | User ID, changed by (self or admin) |
| User Role Changed | `user.role_changed` | User ID, old role, new role, changed by |
| User Login Success | `user.login.success` | User ID, username, IP address, user agent |
| User Login Failed | `user.login.failed` | Username, IP address, reason |
| User Logout | `user.logout` | User ID, username, session ID |

#### 2. OAuth Client Management
**Priority:** 🔴 Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Client Created | `client.created` | Client ID, name, redirect URIs, grant types, created by |
| Client Updated | `client.updated` | Client ID, changed fields, old values, new values, updated by |
| Client Deleted | `client.deleted` | Client ID, name, deleted by |
| Client Secret Rotated | `client.secret_rotated` | Client ID, rotated by |
| Client Registration Access Token Used | `client.registration_token_used` | Client ID, token ID |

#### 3. Authorization & Token Operations
**Priority:** 🟡 High

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Authorization Code Issued | `authz.code_issued` | Code ID, client ID, user ID, scope, redirect URI |
| Authorization Code Used | `authz.code_used` | Code ID, client ID, user ID |
| Access Token Issued | `token.access_issued` | Token ID, client ID, user ID, scope, expiry |
| Refresh Token Issued | `token.refresh_issued` | Token ID, client ID, user ID, expiry |
| Refresh Token Used | `token.refresh_used` | Token ID, client ID, user ID, new token issued |
| Token Revoked | `token.revoked` | Token ID, client ID, user ID, revoked by, reason |
| ID Token Issued | `token.id_issued` | Token ID, client ID, user ID, claims |

#### 4. Session Management
**Priority:** 🟡 High

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Session Created | `session.created` | Session ID, user ID, IP address, user agent |
| Session Updated | `session.updated` | Session ID, user ID, updated fields |
| Session Deleted | `session.deleted` | Session ID, user ID, reason (logout, timeout, admin) |
| Session Expired | `session.expired` | Session ID, user ID, expiry time |

#### 5. Consent Management
**Priority:** 🟡 High

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Consent Granted | `consent.granted` | User ID, client ID, scope, consent ID |
| Consent Updated | `consent.updated` | Consent ID, user ID, client ID, scope changes |
| Consent Revoked | `consent.revoked` | Consent ID, user ID, client ID, revoked by |

#### 6. System Configuration
**Priority:** 🔴 Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Settings Updated | `settings.updated` | Changed fields, old values, new values, updated by |
| Signing Keys Generated | `keys.generated` | Key ID, algorithm, generated by |
| Signing Keys Rotated | `keys.rotated` | Old key ID, new key ID, rotated by |
| Setup Wizard Completed | `setup.completed` | Admin user created, initial config |

#### 7. Registration & Discovery
**Priority:** 🟢 Medium

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Dynamic Client Registration | `registration.client_created` | Client ID, metadata, IP address |
| Client Configuration Read | `registration.config_read` | Client ID, accessed by |
| Client Configuration Updated | `registration.config_updated` | Client ID, changes, updated by |
| Discovery Document Accessed | `discovery.accessed` | IP address, user agent |

#### 8. Admin Actions
**Priority:** 🔴 Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Admin Login | `admin.login` | Admin user ID, IP address, user agent |
| Admin Logout | `admin.logout` | Admin user ID, session duration |
| Admin Action Performed | `admin.action` | Action type, target resource, result |
| Audit Log Viewed | `audit.viewed` | Admin user ID, filters applied, record count |
| Audit Log Exported | `audit.exported` | Admin user ID, date range, format |

#### 9. Security Events
**Priority:** 🔴 Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Invalid Token Used | `security.invalid_token` | Token (partial), client ID, IP address |
| Suspicious Activity Detected | `security.suspicious` | Activity type, details, IP address |
| Rate Limit Exceeded | `security.rate_limit` | Resource, IP address, count |
| CSRF Attack Detected | `security.csrf` | Request details, IP address |
| Invalid Redirect URI | `security.invalid_redirect` | Client ID, attempted URI |

---

## Audit Event Model

### Core Audit Event Structure

```go
// AuditEvent represents a single auditable event
type AuditEvent struct {
    // Core fields
    ID           string                 `json:"id" bson:"_id"`                    // Unique event ID
    Timestamp    time.Time              `json:"timestamp" bson:"timestamp"`       // When event occurred
    EventType    string                 `json:"event_type" bson:"event_type"`     // e.g., "user.created"
    Category     string                 `json:"category" bson:"category"`         // e.g., "user", "client", "token"
    Action       string                 `json:"action" bson:"action"`             // e.g., "created", "updated", "deleted"
    
    // Actor (who performed the action)
    ActorType    string                 `json:"actor_type" bson:"actor_type"`     // "user", "admin", "client", "system"
    ActorID      string                 `json:"actor_id" bson:"actor_id"`         // ID of actor
    ActorName    string                 `json:"actor_name" bson:"actor_name"`     // Display name
    
    // Target (what was affected)
    TargetType   string                 `json:"target_type" bson:"target_type"`   // "user", "client", "token", etc.
    TargetID     string                 `json:"target_id" bson:"target_id"`       // ID of target
    TargetName   string                 `json:"target_name" bson:"target_name"`   // Display name
    
    // Result
    Status       string                 `json:"status" bson:"status"`             // "success", "failure", "error"
    StatusCode   int                    `json:"status_code,omitempty" bson:"status_code,omitempty"` // HTTP status if applicable
    ErrorMessage string                 `json:"error_message,omitempty" bson:"error_message,omitempty"`
    
    // Context
    IPAddress    string                 `json:"ip_address,omitempty" bson:"ip_address,omitempty"`
    UserAgent    string                 `json:"user_agent,omitempty" bson:"user_agent,omitempty"`
    RequestID    string                 `json:"request_id,omitempty" bson:"request_id,omitempty"`
    SessionID    string                 `json:"session_id,omitempty" bson:"session_id,omitempty"`
    
    // Details (flexible structure for event-specific data)
    Details      map[string]interface{} `json:"details,omitempty" bson:"details,omitempty"`
    
    // Changes (for update operations)
    Changes      []FieldChange          `json:"changes,omitempty" bson:"changes,omitempty"`
    
    // Metadata
    Severity     string                 `json:"severity" bson:"severity"`         // "info", "warning", "critical"
    Tags         []string               `json:"tags,omitempty" bson:"tags,omitempty"`
    
    // Tamper detection
    Hash         string                 `json:"hash" bson:"hash"`                 // SHA-256 hash for integrity
}

// FieldChange represents a change to a specific field
type FieldChange struct {
    Field    string      `json:"field" bson:"field"`
    OldValue interface{} `json:"old_value,omitempty" bson:"old_value,omitempty"`
    NewValue interface{} `json:"new_value" bson:"new_value"`
}
```

### Event Categories

```go
const (
    CategoryUser          = "user"
    CategoryClient        = "client"
    CategoryToken         = "token"
    CategorySession       = "session"
    CategoryConsent       = "consent"
    CategorySettings      = "settings"
    CategoryKeys          = "keys"
    CategoryRegistration  = "registration"
    CategoryDiscovery     = "discovery"
    CategoryAdmin         = "admin"
    CategorySecurity      = "security"
    CategorySystem        = "system"
)
```

### Event Actions

```go
const (
    ActionCreated  = "created"
    ActionUpdated  = "updated"
    ActionDeleted  = "deleted"
    ActionRead     = "read"
    ActionIssued   = "issued"
    ActionUsed     = "used"
    ActionRevoked  = "revoked"
    ActionGranted  = "granted"
    ActionDenied   = "denied"
    ActionRotated  = "rotated"
    ActionAccessed = "accessed"
)
```

### Actor Types

```go
const (
    ActorTypeUser   = "user"
    ActorTypeAdmin  = "admin"
    ActorTypeClient = "client"
    ActorTypeSystem = "system"
)
```

### Severity Levels

```go
const (
    SeverityInfo     = "info"     // Normal operations
    SeverityWarning  = "warning"  // Unusual but not critical
    SeverityCritical = "critical" // Security-sensitive operations
)
```

---

## Storage Architecture

### Audit Storage Interface

```go
// AuditStorage defines the interface for audit event persistence
type AuditStorage interface {
    // Create audit event
    CreateAuditEvent(event *models.AuditEvent) error
    
    // Query audit events
    GetAuditEvents(filter AuditFilter) ([]*models.AuditEvent, error)
    GetAuditEventByID(id string) (*models.AuditEvent, error)
    
    // Count and statistics
    CountAuditEvents(filter AuditFilter) (int64, error)
    GetAuditStatistics(from, to time.Time) (*AuditStatistics, error)
    
    // Bulk operations
    CreateAuditEventsBatch(events []*models.AuditEvent) error
    
    // Cleanup (for retention policies)
    DeleteAuditEventsBefore(timestamp time.Time) error
    
    // Export
    ExportAuditEvents(filter AuditFilter, format string) ([]byte, error)
    
    // Health check
    Ping() error
}

// AuditFilter defines query filters
type AuditFilter struct {
    // Time range
    FromTime *time.Time
    ToTime   *time.Time
    
    // Filtering
    EventTypes []string
    Categories []string
    Actions    []string
    ActorIDs   []string
    TargetIDs  []string
    Statuses   []string
    Severities []string
    
    // Search
    SearchText string // Search in event details
    
    // Pagination
    Offset int
    Limit  int
    
    // Sorting
    SortBy    string // "timestamp", "severity", etc.
    SortOrder string // "asc", "desc"
}

// AuditStatistics provides aggregate statistics
type AuditStatistics struct {
    TotalEvents      int64                       `json:"total_events"`
    EventsByCategory map[string]int64            `json:"events_by_category"`
    EventsByAction   map[string]int64            `json:"events_by_action"`
    EventsBySeverity map[string]int64            `json:"events_by_severity"`
    FailureCount     int64                       `json:"failure_count"`
    TopActors        []ActorStats                `json:"top_actors"`
    TopTargets       []TargetStats               `json:"top_targets"`
    EventTimeline    map[string]int64            `json:"event_timeline"` // Date -> count
}

type ActorStats struct {
    ActorID    string `json:"actor_id"`
    ActorName  string `json:"actor_name"`
    EventCount int64  `json:"event_count"`
}

type TargetStats struct {
    TargetType string `json:"target_type"`
    TargetID   string `json:"target_id"`
    EventCount int64  `json:"event_count"`
}
```

### Storage Backend Types

#### 1. JSON Audit Storage

```go
// JSONAuditStorage implements audit storage using JSON files
type JSONAuditStorage struct {
    filePath string
    mu       sync.RWMutex
    events   []*models.AuditEvent
}

// Features:
// - Single JSON file with array of events
// - Append-only for integrity
// - Rotation when file size exceeds threshold
// - In-memory cache for recent events
// - Periodic flush to disk
```

#### 2. MongoDB Audit Storage

```go
// MongoDBAuditStorage implements audit storage using MongoDB
type MongoDBAuditStorage struct {
    client     *mongo.Client
    database   *mongo.Database
    collection *mongo.Collection
}

// Features:
// - Dedicated audit collection
// - Indexes on timestamp, event_type, actor_id, target_id
// - TTL index for automatic retention
// - Aggregation pipeline for statistics
// - Efficient querying and filtering
```

### Configuration

```go
// AuditConfig holds audit logging configuration
type AuditConfig struct {
    Enabled      bool   `json:"enabled" bson:"enabled"`
    StorageType  string `json:"storage_type" bson:"storage_type"` // "json" or "mongodb"
    
    // JSON backend
    JSONFilePath     string `json:"json_file_path,omitempty" bson:"json_file_path,omitempty"`
    MaxFileSizeMB    int    `json:"max_file_size_mb,omitempty" bson:"max_file_size_mb,omitempty"`
    RotationEnabled  bool   `json:"rotation_enabled,omitempty" bson:"rotation_enabled,omitempty"`
    
    // MongoDB backend (can use same as main storage or separate)
    MongoURI         string `json:"mongo_uri,omitempty" bson:"mongo_uri,omitempty"`
    MongoDatabase    string `json:"mongo_database,omitempty" bson:"mongo_database,omitempty"`
    MongoCollection  string `json:"mongo_collection,omitempty" bson:"mongo_collection,omitempty"`
    
    // Retention
    RetentionDays    int    `json:"retention_days" bson:"retention_days"` // 0 = forever
    
    // Performance
    AsyncLogging     bool   `json:"async_logging" bson:"async_logging"`
    BufferSize       int    `json:"buffer_size" bson:"buffer_size"`
    FlushIntervalSec int    `json:"flush_interval_sec" bson:"flush_interval_sec"`
    
    // Privacy
    RedactSensitiveData bool `json:"redact_sensitive_data" bson:"redact_sensitive_data"`
}
```

---

## Implementation Tasks

### Phase 1: Core Audit Infrastructure (2 days)

#### Task 1.1: Create Audit Models
**File:** `backend/pkg/models/audit.go`

```go
package models

// Create AuditEvent, FieldChange, and related structs
// Add constants for categories, actions, actor types, severities
// Add helper methods for creating common audit events
```

#### Task 1.2: Create Audit Storage Interface
**File:** `backend/pkg/audit/storage.go`

```go
package audit

// Define AuditStorage interface
// Define AuditFilter, AuditStatistics structs
// Add storage factory function
```

#### Task 1.3: Implement JSON Audit Storage
**File:** `backend/pkg/audit/json_storage.go`

```go
package audit

type JSONAuditStorage struct {
    filePath string
    mu       sync.RWMutex
    buffer   []*models.AuditEvent
}

// Implement all AuditStorage interface methods
// Add file rotation logic
// Add buffering and flushing
// Add query filtering
```

#### Task 1.4: Implement MongoDB Audit Storage
**File:** `backend/pkg/audit/mongo_storage.go`

```go
package audit

type MongoDBAuditStorage struct {
    client     *mongo.Client
    database   *mongo.Database
    collection *mongo.Collection
}

// Implement all AuditStorage interface methods
// Create indexes
// Implement aggregation queries
// Add TTL index for retention
```

---

### Phase 2: Audit Middleware & Logger (2 days)

#### Task 2.1: Create Audit Logger Service
**File:** `backend/pkg/audit/logger.go`

```go
package audit

// AuditLogger provides high-level audit logging API
type AuditLogger struct {
    storage      AuditStorage
    config       *AuditConfig
    buffer       chan *models.AuditEvent
    hasher       hash.Hash
    systemActor  *models.Actor
}

// Methods for logging common events
func (al *AuditLogger) LogUserCreated(actor, target *models.User, details map[string]interface{}) error
func (al *AuditLogger) LogUserUpdated(actor *models.User, target *models.User, changes []models.FieldChange) error
func (al *AuditLogger) LogUserDeleted(actor *models.User, targetID string) error
func (al *AuditLogger) LogUserLogin(user *models.User, success bool, ip, userAgent string) error

func (al *AuditLogger) LogClientCreated(actor *models.User, client *models.Client) error
func (al *AuditLogger) LogClientUpdated(actor *models.User, client *models.Client, changes []models.FieldChange) error
func (al *AuditLogger) LogClientDeleted(actor *models.User, clientID string) error

func (al *AuditLogger) LogTokenIssued(client *models.Client, user *models.User, tokenType string) error
func (al *AuditLogger) LogTokenRevoked(actor *models.User, tokenID string, reason string) error

func (al *AuditLogger) LogSettingsUpdated(actor *models.User, changes []models.FieldChange) error
func (al *AuditLogger) LogKeysRotated(actor *models.User, oldKeyID, newKeyID string) error

// Generic method for custom events
func (al *AuditLogger) Log(event *models.AuditEvent) error

// Background worker for async logging
func (al *AuditLogger) Start() error
func (al *AuditLogger) Stop() error
```

#### Task 2.2: Create Audit Middleware
**File:** `backend/pkg/middleware/audit.go`

```go
package middleware

// AuditMiddleware logs HTTP requests that modify data
func AuditMiddleware(auditLogger *audit.AuditLogger) echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            // Skip GET requests (read-only)
            if c.Request().Method == "GET" || c.Request().Method == "OPTIONS" {
                return next(c)
            }
            
            // Capture request start time
            start := time.Now()
            
            // Extract actor from context (user or client)
            actor := extractActor(c)
            
            // Call next handler
            err := next(c)
            
            // Log audit event after request completes
            go logRequestAudit(auditLogger, c, actor, start, err)
            
            return err
        }
    }
}
```

---

### Phase 3: Integrate Audit Logging (2 days)

#### Task 3.1: Add Audit Logging to User Handlers
**File:** `backend/pkg/handlers/admin.go`

```go
// Example: CreateUser
func (h *AdminHandler) CreateUser(c echo.Context) error {
    // ... existing code to create user ...
    
    // Add audit logging
    actor := getActorFromContext(c)
    h.auditLogger.LogUserCreated(actor, newUser, map[string]interface{}{
        "ip_address": c.RealIP(),
        "user_agent": c.Request().UserAgent(),
    })
    
    return c.JSON(http.StatusCreated, response)
}

// Example: UpdateUser
func (h *AdminHandler) UpdateUser(c echo.Context) error {
    // ... get old user ...
    // ... update user ...
    
    // Calculate changes
    changes := calculateUserChanges(oldUser, updatedUser)
    
    // Add audit logging
    actor := getActorFromContext(c)
    h.auditLogger.LogUserUpdated(actor, updatedUser, changes)
    
    return c.JSON(http.StatusOK, updatedUser)
}

// Example: DeleteUser
func (h *AdminHandler) DeleteUser(c echo.Context) error {
    userID := c.Param("id")
    
    // ... get user for logging ...
    user, _ := h.store.GetUserByID(userID)
    
    // Delete user
    err := h.store.DeleteUser(userID)
    
    // Add audit logging
    actor := getActorFromContext(c)
    h.auditLogger.LogUserDeleted(actor, userID, map[string]interface{}{
        "username": user.Username,
        "email":    user.Email,
    })
    
    return c.NoContent(http.StatusNoContent)
}
```

#### Task 3.2: Add Audit Logging to Client Handlers
**File:** `backend/pkg/handlers/registration.go`

```go
// Add audit logging to Register, UpdateClientConfiguration, DeleteClientConfiguration
```

#### Task 3.3: Add Audit Logging to Token Handlers
**File:** `backend/pkg/handlers/token.go`

```go
// Add audit logging to token issuance, refresh, revocation
```

#### Task 3.4: Add Audit Logging to Settings Handlers
**File:** `backend/pkg/handlers/admin.go`

```go
// Add audit logging to settings updates, key rotation
```

#### Task 3.5: Add Audit Logging to Auth Handlers
**File:** `backend/pkg/handlers/handlers.go`

```go
// Add audit logging to login, logout, consent
```

---

### Phase 4: Admin UI for Audit Logs (2-3 days)

#### Task 4.1: Create Audit API Handlers
**File:** `backend/pkg/handlers/audit.go`

```go
package handlers

type AuditHandler struct {
    auditStorage audit.AuditStorage
    store        storage.Storage
}

// GetAuditEvents returns paginated audit events with filters
func (h *AuditHandler) GetAuditEvents(c echo.Context) error {
    // Parse query parameters
    filter := parseAuditFilter(c)
    
    // Get events from storage
    events, err := h.auditStorage.GetAuditEvents(filter)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to fetch audit events",
        })
    }
    
    // Get total count
    total, _ := h.auditStorage.CountAuditEvents(filter)
    
    return c.JSON(http.StatusOK, map[string]interface{}{
        "events": events,
        "total":  total,
        "offset": filter.Offset,
        "limit":  filter.Limit,
    })
}

// GetAuditEventByID returns a single audit event
func (h *AuditHandler) GetAuditEventByID(c echo.Context) error {
    id := c.Param("id")
    
    event, err := h.auditStorage.GetAuditEventByID(id)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "Audit event not found",
        })
    }
    
    return c.JSON(http.StatusOK, event)
}

// GetAuditStatistics returns aggregate statistics
func (h *AuditHandler) GetAuditStatistics(c echo.Context) error {
    from := parseTime(c.QueryParam("from"))
    to := parseTime(c.QueryParam("to"))
    
    stats, err := h.auditStorage.GetAuditStatistics(from, to)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to fetch statistics",
        })
    }
    
    return c.JSON(http.StatusOK, stats)
}

// ExportAuditEvents exports audit logs in various formats
func (h *AuditHandler) ExportAuditEvents(c echo.Context) error {
    filter := parseAuditFilter(c)
    format := c.QueryParam("format") // "json", "csv", "pdf"
    
    data, err := h.auditStorage.ExportAuditEvents(filter, format)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to export audit events",
        })
    }
    
    // Set appropriate headers
    c.Response().Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=audit-logs.%s", format))
    
    return c.Blob(http.StatusOK, getContentType(format), data)
}
```

#### Task 4.2: Add Audit Routes
**File:** `backend/cmd/serve.go`

```go
// Audit endpoints (admin only)
auditHandler := handlers.NewAuditHandler(auditStorage, store)
api.GET("/audit/events", auditHandler.GetAuditEvents)
api.GET("/audit/events/:id", auditHandler.GetAuditEventByID)
api.GET("/audit/statistics", auditHandler.GetAuditStatistics)
api.GET("/audit/export", auditHandler.ExportAuditEvents)
```

#### Task 4.3: Create Audit Logs Frontend Page
**File:** `frontend/src/pages/AuditLogs.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  TextField,
  Select,
  MenuItem,
  Button,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  Pagination,
} from '@mui/material';
import {
  FilterList,
  Download,
  Visibility,
  Refresh,
} from '@mui/icons-material';

interface AuditEvent {
  id: string;
  timestamp: string;
  event_type: string;
  category: string;
  action: string;
  actor_name: string;
  target_name: string;
  status: string;
  severity: string;
  ip_address?: string;
}

export default function AuditLogs() {
  const [events, setEvents] = useState<AuditEvent[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedEvent, setSelectedEvent] = useState<AuditEvent | null>(null);
  const [filters, setFilters] = useState({
    category: '',
    action: '',
    severity: '',
    searchText: '',
    fromDate: '',
    toDate: '',
  });
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const fetchAuditEvents = async () => {
    setLoading(true);
    try {
      const queryParams = new URLSearchParams({
        offset: String((page - 1) * 50),
        limit: '50',
        ...filters,
      });
      
      const response = await fetch(`/api/admin/audit/events?${queryParams}`);
      const data = await response.json();
      
      setEvents(data.events);
      setTotalPages(Math.ceil(data.total / 50));
    } catch (error) {
      console.error('Failed to fetch audit events:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleExport = async (format: string) => {
    const queryParams = new URLSearchParams({ format, ...filters });
    window.open(`/api/admin/audit/export?${queryParams}`, '_blank');
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'critical': return 'error';
      case 'warning': return 'warning';
      default: return 'info';
    }
  };

  const getStatusColor = (status: string) => {
    return status === 'success' ? 'success' : 'error';
  };

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4" fontWeight="bold">
          Audit Logs
        </Typography>
        <Box display="flex" gap={1}>
          <Button
            startIcon={<Refresh />}
            onClick={fetchAuditEvents}
            variant="outlined"
          >
            Refresh
          </Button>
          <Button
            startIcon={<Download />}
            onClick={() => handleExport('csv')}
            variant="outlined"
          >
            Export CSV
          </Button>
          <Button
            startIcon={<Download />}
            onClick={() => handleExport('json')}
            variant="outlined"
          >
            Export JSON
          </Button>
        </Box>
      </Box>

      {/* Filters */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Box display="flex" gap={2} flexWrap="wrap">
          <TextField
            label="Search"
            value={filters.searchText}
            onChange={(e) => setFilters({ ...filters, searchText: e.target.value })}
            size="small"
            sx={{ minWidth: 200 }}
          />
          <Select
            value={filters.category}
            onChange={(e) => setFilters({ ...filters, category: e.target.value })}
            displayEmpty
            size="small"
            sx={{ minWidth: 150 }}
          >
            <MenuItem value="">All Categories</MenuItem>
            <MenuItem value="user">User</MenuItem>
            <MenuItem value="client">Client</MenuItem>
            <MenuItem value="token">Token</MenuItem>
            <MenuItem value="session">Session</MenuItem>
            <MenuItem value="settings">Settings</MenuItem>
          </Select>
          <Select
            value={filters.severity}
            onChange={(e) => setFilters({ ...filters, severity: e.target.value })}
            displayEmpty
            size="small"
            sx={{ minWidth: 150 }}
          >
            <MenuItem value="">All Severities</MenuItem>
            <MenuItem value="info">Info</MenuItem>
            <MenuItem value="warning">Warning</MenuItem>
            <MenuItem value="critical">Critical</MenuItem>
          </Select>
          <TextField
            label="From Date"
            type="datetime-local"
            value={filters.fromDate}
            onChange={(e) => setFilters({ ...filters, fromDate: e.target.value })}
            size="small"
            InputLabelProps={{ shrink: true }}
          />
          <TextField
            label="To Date"
            type="datetime-local"
            value={filters.toDate}
            onChange={(e) => setFilters({ ...filters, toDate: e.target.value })}
            size="small"
            InputLabelProps={{ shrink: true }}
          />
          <Button
            startIcon={<FilterList />}
            onClick={fetchAuditEvents}
            variant="contained"
          >
            Apply Filters
          </Button>
        </Box>
      </Paper>

      {/* Audit Events Table */}
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Timestamp</TableCell>
              <TableCell>Event Type</TableCell>
              <TableCell>Actor</TableCell>
              <TableCell>Target</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Severity</TableCell>
              <TableCell>IP Address</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {events.map((event) => (
              <TableRow key={event.id} hover>
                <TableCell>
                  {new Date(event.timestamp).toLocaleString()}
                </TableCell>
                <TableCell>
                  <Chip label={event.event_type} size="small" variant="outlined" />
                </TableCell>
                <TableCell>{event.actor_name}</TableCell>
                <TableCell>{event.target_name}</TableCell>
                <TableCell>
                  <Chip
                    label={event.status}
                    size="small"
                    color={getStatusColor(event.status)}
                  />
                </TableCell>
                <TableCell>
                  <Chip
                    label={event.severity}
                    size="small"
                    color={getSeverityColor(event.severity)}
                  />
                </TableCell>
                <TableCell>{event.ip_address || '-'}</TableCell>
                <TableCell>
                  <IconButton
                    size="small"
                    onClick={() => setSelectedEvent(event)}
                  >
                    <Visibility />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>

      <Box display="flex" justifyContent="center" mt={3}>
        <Pagination
          count={totalPages}
          page={page}
          onChange={(e, value) => setPage(value)}
          color="primary"
        />
      </Box>

      {/* Event Details Dialog */}
      <Dialog
        open={!!selectedEvent}
        onClose={() => setSelectedEvent(null)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Audit Event Details</DialogTitle>
        <DialogContent>
          {selectedEvent && (
            <Box>
              <pre style={{ whiteSpace: 'pre-wrap' }}>
                {JSON.stringify(selectedEvent, null, 2)}
              </pre>
            </Box>
          )}
        </DialogContent>
      </Dialog>
    </Box>
  );
}
```

#### Task 4.4: Add Audit Logs to Navigation
**File:** `frontend/src/components/Layout.tsx`

```tsx
// Add menu item for Audit Logs
<ListItem button component={Link} to="/audit-logs">
  <ListItemIcon>
    <HistoryIcon />
  </ListItemIcon>
  <ListItemText primary="Audit Logs" />
</ListItem>
```

---

### Phase 5: Testing & Documentation (1-2 days)

#### Task 5.1: Unit Tests
**File:** `backend/pkg/audit/logger_test.go`

Test cases:
- Audit event creation
- Field change calculation
- Hash generation and verification
- Filter query building
- Statistics aggregation

#### Task 5.2: Integration Tests
**File:** `backend/pkg/handlers/admin_test.go`

Test cases:
- Verify audit events created on user CRUD
- Verify audit events created on client CRUD
- Verify audit events created on token operations
- Verify audit events created on settings changes

#### Task 5.3: Performance Tests

Test cases:
- High-volume event logging (1000+ events/sec)
- Query performance with large datasets
- Export performance
- Memory usage during buffering

#### Task 5.4: Documentation
**File:** `docs/AUDIT_LOGGING.md`

Document:
- What events are audited
- Audit event structure
- How to query audit logs
- Retention policies
- Export formats
- Security considerations
- Compliance features

---

## Performance Considerations

### 1. Asynchronous Logging
- Log audit events asynchronously to avoid blocking request handlers
- Use buffered channels with configurable size
- Background worker flushes to storage periodically

### 2. Buffering Strategy
```go
// Buffer in memory, flush periodically or when buffer is full
const (
    DefaultBufferSize = 1000
    DefaultFlushInterval = 10 * time.Second
)
```

### 3. Storage Optimization

**JSON Storage:**
- Rotate files when they reach size threshold (e.g., 100MB)
- Compress old files
- Index recent events in memory

**MongoDB Storage:**
- Create indexes on frequently queried fields
- Use TTL indexes for automatic cleanup
- Use aggregation pipeline for statistics

### 4. Query Performance
- Implement pagination for all list endpoints
- Add caching for statistics
- Limit default query ranges (e.g., last 30 days)
- Add query timeouts

### 5. Data Volume Management
- Implement retention policies (delete events after N days)
- Archive old events to cold storage
- Compress exported data

---

## Security & Compliance

### 1. Tamper Detection
- Generate SHA-256 hash for each event
- Include previous event hash (blockchain-style)
- Verify hash chain on queries

```go
func (al *AuditLogger) calculateHash(event *models.AuditEvent, prevHash string) string {
    data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%s",
        event.Timestamp.Format(time.RFC3339Nano),
        event.EventType,
        event.ActorID,
        event.TargetID,
        event.Status,
        prevHash,
        event.ID,
    )
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

### 2. Data Privacy
- Redact sensitive data (passwords, secrets)
- Comply with GDPR (right to be forgotten)
- Implement data minimization
- Pseudonymize when appropriate

```go
func (al *AuditLogger) redactSensitiveFields(details map[string]interface{}) {
    sensitiveFields := []string{"password", "secret", "token", "credit_card"}
    for _, field := range sensitiveFields {
        if _, exists := details[field]; exists {
            details[field] = "[REDACTED]"
        }
    }
}
```

### 3. Access Control
- Only admins can view audit logs
- Log audit log access (meta-auditing)
- Implement role-based access (e.g., security team vs. support team)

### 4. Compliance Features
- **GDPR**: Right to access, right to erasure
- **SOC 2**: Comprehensive logging, access controls
- **ISO 27001**: Security event logging
- **HIPAA**: Audit trail for healthcare data
- **PCI DSS**: Payment processing audit requirements

### 5. Immutability
- JSON storage: Append-only files
- MongoDB: Disable updates/deletes on audit collection
- Consider write-once-read-many (WORM) storage

---

## Timeline

| Phase | Tasks | Duration | Dependencies |
|-------|-------|----------|--------------|
| Phase 1 | Core infrastructure | 2 days | None |
| Phase 2 | Middleware & logger | 2 days | Phase 1 |
| Phase 3 | Integration | 2 days | Phase 2 |
| Phase 4 | Admin UI | 2-3 days | Phase 3 |
| Phase 5 | Testing & docs | 1-2 days | Phase 4 |
| **Total** | | **9-11 days** | |

---

## Success Criteria

1. ✅ All state-changing operations generate audit events
2. ✅ Audit events stored in separate storage (JSON or MongoDB)
3. ✅ Admin UI displays audit logs with filtering and search
4. ✅ Export functionality (CSV, JSON)
5. ✅ Statistics and visualizations available
6. ✅ Async logging doesn't impact request performance
7. ✅ Tamper detection implemented
8. ✅ Sensitive data redacted
9. ✅ Retention policies implemented
10. ✅ Comprehensive documentation
11. ✅ All tests passing

---

## Example Audit Events

### User Created
```json
{
  "id": "audit_123",
  "timestamp": "2025-10-24T10:30:00Z",
  "event_type": "user.created",
  "category": "user",
  "action": "created",
  "actor_type": "admin",
  "actor_id": "admin_1",
  "actor_name": "Admin User",
  "target_type": "user",
  "target_id": "user_456",
  "target_name": "john.doe",
  "status": "success",
  "severity": "info",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0...",
  "details": {
    "username": "john.doe",
    "email": "john@example.com",
    "role": "user"
  },
  "hash": "abc123..."
}
```

### Client Updated
```json
{
  "id": "audit_124",
  "timestamp": "2025-10-24T10:35:00Z",
  "event_type": "client.updated",
  "category": "client",
  "action": "updated",
  "actor_type": "admin",
  "actor_id": "admin_1",
  "actor_name": "Admin User",
  "target_type": "client",
  "target_id": "client_789",
  "target_name": "My App",
  "status": "success",
  "severity": "warning",
  "changes": [
    {
      "field": "redirect_uris",
      "old_value": ["https://old.example.com/callback"],
      "new_value": ["https://new.example.com/callback"]
    }
  ],
  "hash": "def456..."
}
```

### Failed Login
```json
{
  "id": "audit_125",
  "timestamp": "2025-10-24T10:40:00Z",
  "event_type": "user.login.failed",
  "category": "security",
  "action": "denied",
  "actor_type": "user",
  "actor_id": "unknown",
  "actor_name": "unknown_user",
  "target_type": "system",
  "target_id": "auth",
  "status": "failure",
  "severity": "warning",
  "ip_address": "192.168.1.200",
  "error_message": "Invalid credentials",
  "details": {
    "username": "attacker",
    "attempt_count": 5
  },
  "tags": ["security", "authentication", "failed_login"],
  "hash": "ghi789..."
}
```

---

## References

- [ISO 27001 - Audit Logging Requirements](https://www.iso.org/standard/54534.html)
- [SOC 2 - Security Logging Best Practices](https://www.aicpa.org/interestareas/frc/assuranceadvisoryservices/sorhome)
- [GDPR - Right to Access and Audit](https://gdpr-info.eu/)
- [NIST SP 800-92 - Guide to Computer Security Log Management](https://csrc.nist.gov/publications/detail/sp/800-92/final)
- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)
