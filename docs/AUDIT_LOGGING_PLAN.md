# Comprehensive Audit Logging Implementation Plan

**Document Version:** 1.0  
**Date:** October 24, 2025  
**Status:** Planning Phase  
**Scope:** All state-changing operations across the OpenID Provider

---

## Table of Contents

- [Executive Summary](#executive-summary)
- [What to Audit](#what-to-audit)
- [Audit Event Model](#audit-event-model)
- [Storage Architecture](#storage-architecture)
- [Implementation Tasks](#implementation-tasks)
- [Admin UI Integration](#admin-ui-integration)
- [Performance Considerations](#performance-considerations)
- [Security & Compliance](#security--compliance)

---

## Executive Summary

This document outlines the plan to implement **comprehensive audit logging** for the OpenID Provider. Every operation that creates, modifies, or deletes system data will be logged to a dedicated audit store, providing complete traceability for security, compliance, and debugging purposes.

**Key Features:**
- Audit all state-changing operations (Create, Update, Delete)
- Separate audit storage (JSON or MongoDB)
- Admin UI for viewing and filtering audit logs
- Tamper-resistant audit trail
- Performance-optimized async logging
- Compliance-ready (GDPR, SOC 2, ISO 27001)

**Estimated Effort:** 6-8 days

---

## What to Audit

### Categories of Auditable Events

#### 1. User Management Operations
**Priority:** ðŸ”´ Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| User Created | `user.created` | User ID, username, email, role, created by |
| User Updated | `user.updated` | User ID, changed fields, old values, new values, updated by |
| User Deleted | `user.deleted` | User ID, username, email, deleted by |
| User Password Changed | `user.password_changed` | User ID, changed by (self or admin) |
| User Role Changed | `user.role_changed` | User ID, old role, new role, changed by |
| User Login Success | `user.login.success` | User ID, username, IP address, user agent |
| User Login Failed | `user.login.failed` | Username, IP address, reason |
| User Logout | `user.logout` | User ID, username, session ID |

#### 2. OAuth Client Management
**Priority:** ðŸ”´ Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Client Created | `client.created` | Client ID, name, redirect URIs, grant types, created by |
| Client Updated | `client.updated` | Client ID, changed fields, old values, new values, updated by |
| Client Deleted | `client.deleted` | Client ID, name, deleted by |
| Client Secret Rotated | `client.secret_rotated` | Client ID, rotated by |
| Client Registration Access Token Used | `client.registration_token_used` | Client ID, token ID |

#### 3. Authorization & Token Operations
**Priority:** ðŸŸ¡ High

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Authorization Code Issued | `authz.code_issued` | Code ID, client ID, user ID, scope, redirect URI |
| Authorization Code Used | `authz.code_used` | Code ID, client ID, user ID |
| Access Token Issued | `token.access_issued` | Token ID, client ID, user ID, scope, expiry |
| Refresh Token Issued | `token.refresh_issued` | Token ID, client ID, user ID, expiry |
| Refresh Token Used | `token.refresh_used` | Token ID, client ID, user ID, new token issued |
| Token Revoked | `token.revoked` | Token ID, client ID, user ID, revoked by, reason |
| ID Token Issued | `token.id_issued` | Token ID, client ID, user ID, claims |

#### 4. Session Management
**Priority:** ðŸŸ¡ High

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Session Created | `session.created` | Session ID, user ID, IP address, user agent |
| Session Updated | `session.updated` | Session ID, user ID, updated fields |
| Session Deleted | `session.deleted` | Session ID, user ID, reason (logout, timeout, admin) |
| Session Expired | `session.expired` | Session ID, user ID, expiry time |

#### 5. Consent Management
**Priority:** ðŸŸ¡ High

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Consent Granted | `consent.granted` | User ID, client ID, scope, consent ID |
| Consent Updated | `consent.updated` | Consent ID, user ID, client ID, scope changes |
| Consent Revoked | `consent.revoked` | Consent ID, user ID, client ID, revoked by |

#### 6. System Configuration
**Priority:** ðŸ”´ Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Settings Updated | `settings.updated` | Changed fields, old values, new values, updated by |
| Signing Keys Generated | `keys.generated` | Key ID, algorithm, generated by |
| Signing Keys Rotated | `keys.rotated` | Old key ID, new key ID, rotated by |
| Setup Wizard Completed | `setup.completed` | Admin user created, initial config |

#### 7. Registration & Discovery
**Priority:** ðŸŸ¢ Medium

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Dynamic Client Registration | `registration.client_created` | Client ID, metadata, IP address |
| Client Configuration Read | `registration.config_read` | Client ID, accessed by |
| Client Configuration Updated | `registration.config_updated` | Client ID, changes, updated by |
| Discovery Document Accessed | `discovery.accessed` | IP address, user agent |

#### 8. Admin Actions
**Priority:** ðŸ”´ Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Admin Login | `admin.login` | Admin user ID, IP address, user agent |
| Admin Logout | `admin.logout` | Admin user ID, session duration |
| Admin Action Performed | `admin.action` | Action type, target resource, result |
| Audit Log Viewed | `audit.viewed` | Admin user ID, filters applied, record count |
| Audit Log Exported | `audit.exported` | Admin user ID, date range, format |

#### 9. Security Events
**Priority:** ðŸ”´ Critical

| Operation | Event Type | Details to Log |
|-----------|-----------|----------------|
| Invalid Token Used | `security.invalid_token` | Token (partial), client ID, IP address |
| Suspicious Activity Detected | `security.suspicious` | Activity type, details, IP address |
| Rate Limit Exceeded | `security.rate_limit` | Resource, IP address, count |
| CSRF Attack Detected | `security.csrf` | Request details, IP address |
| Invalid Redirect URI | `security.invalid_redirect` | Client ID, attempted URI |

---

## Audit Event Model

### Core Audit Event Structure

```go
// AuditEvent represents a single auditable event
type AuditEvent struct {
    // Core fields
    ID           string                 `json:"id" bson:"_id"`                    // Unique event ID
    Timestamp    time.Time              `json:"timestamp" bson:"timestamp"`       // When event occurred
    EventType    string                 `json:"event_type" bson:"event_type"`     // e.g., "user.created"
    Category     string                 `json:"category" bson:"category"`         // e.g., "user", "client", "token"
    Action       string                 `json:"action" bson:"action"`             // e.g., "created", "updated", "deleted"
    
    // Actor (who performed the action)
    ActorType    string                 `json:"actor_type" bson:"actor_type"`     // "user", "admin", "client", "system"
    ActorID      string                 `json:"actor_id" bson:"actor_id"`         // ID of actor
    ActorName    string                 `json:"actor_name" bson:"actor_name"`     // Display name
    
    // Target (what was affected)
    TargetType   string                 `json:"target_type" bson:"target_type"`   // "user", "client", "token", etc.
    TargetID     string                 `json:"target_id" bson:"target_id"`       // ID of target
    TargetName   string                 `json:"target_name" bson:"target_name"`   // Display name
    
    // Result
    Status       string                 `json:"status" bson:"status"`             // "success", "failure", "error"
    StatusCode   int                    `json:"status_code,omitempty" bson:"status_code,omitempty"` // HTTP status if applicable
    ErrorMessage string                 `json:"error_message,omitempty" bson:"error_message,omitempty"`
    
    // Context
    IPAddress    string                 `json:"ip_address,omitempty" bson:"ip_address,omitempty"`
    UserAgent    string                 `json:"user_agent,omitempty" bson:"user_agent,omitempty"`
    RequestID    string                 `json:"request_id,omitempty" bson:"request_id,omitempty"`
    SessionID    string                 `json:"session_id,omitempty" bson:"session_id,omitempty"`
    
    // Details (flexible structure for event-specific data)
    Details      map[string]interface{} `json:"details,omitempty" bson:"details,omitempty"`
    
    // Changes (for update operations)
    Changes      []FieldChange          `json:"changes,omitempty" bson:"changes,omitempty"`
    
    // Metadata
    Severity     string                 `json:"severity" bson:"severity"`         // "info", "warning", "critical"
    Tags         []string               `json:"tags,omitempty" bson:"tags,omitempty"`
    
    // Tamper detection
    Hash         string                 `json:"hash" bson:"hash"`                 // SHA-256 hash for integrity
}

// FieldChange represents a change to a specific field
type FieldChange struct {
    Field    string      `json:"field" bson:"field"`
    OldValue interface{} `json:"old_value,omitempty" bson:"old_value,omitempty"`
    NewValue interface{} `json:"new_value" bson:"new_value"`
}
```

### Event Categories

```go
const (
    CategoryUser          = "user"
    CategoryClient        = "client"
    CategoryToken         = "token"
    CategorySession       = "session"
    CategoryConsent       = "consent"
    CategorySettings      = "settings"
    CategoryKeys          = "keys"
    CategoryRegistration  = "registration"
    CategoryDiscovery     = "discovery"
    CategoryAdmin         = "admin"
    CategorySecurity      = "security"
    CategorySystem        = "system"
)
```

### Event Actions

```go
const (
    ActionCreated  = "created"
    ActionUpdated  = "updated"
    ActionDeleted  = "deleted"
    ActionRead     = "read"
    ActionIssued   = "issued"
    ActionUsed     = "used"
    ActionRevoked  = "revoked"
    ActionGranted  = "granted"
    ActionDenied   = "denied"
    ActionRotated  = "rotated"
    ActionAccessed = "accessed"
)
```

### Actor Types

```go
const (
    ActorTypeUser   = "user"
    ActorTypeAdmin  = "admin"
    ActorTypeClient = "client"
    ActorTypeSystem = "system"
)
```

### Severity Levels

```go
const (
    SeverityInfo     = "info"     // Normal operations
    SeverityWarning  = "warning"  // Unusual but not critical
    SeverityCritical = "critical" // Security-sensitive operations
)
```

---

## Storage Architecture

### Audit Storage Interface

```go
// AuditStorage defines the interface for audit event persistence
type AuditStorage interface {
    // Create audit event
    CreateAuditEvent(event *models.AuditEvent) error
    
    // Query audit events
    GetAuditEvents(filter AuditFilter) ([]*models.AuditEvent, error)
    GetAuditEventByID(id string) (*models.AuditEvent, error)
    
    // Count and statistics
    CountAuditEvents(filter AuditFilter) (int64, error)
    GetAuditStatistics(from, to time.Time) (*AuditStatistics, error)
    
    // Bulk operations
    CreateAuditEventsBatch(events []*models.AuditEvent) error
    
    // Cleanup (for retention policies)
    DeleteAuditEventsBefore(timestamp time.Time) error
    
    // Export
    ExportAuditEvents(filter AuditFilter, format string) ([]byte, error)
    
    // Health check
    Ping() error
}

// AuditFilter defines query filters
type AuditFilter struct {
    // Time range
    FromTime *time.Time
    ToTime   *time.Time
    
    // Filtering
    EventTypes []string
    Categories []string
    Actions    []string
    ActorIDs   []string
    TargetIDs  []string
    Statuses   []string
    Severities []string
    
    // Search
    SearchText string // Search in event details
    
    // Pagination
    Offset int
    Limit  int
    
    // Sorting
    SortBy    string // "timestamp", "severity", etc.
    SortOrder string // "asc", "desc"
}

// AuditStatistics provides aggregate statistics
type AuditStatistics struct {
    TotalEvents      int64                       `json:"total_events"`
    EventsByCategory map[string]int64            `json:"events_by_category"`
    EventsByAction   map[string]int64            `json:"events_by_action"`
    EventsBySeverity map[string]int64            `json:"events_by_severity"`
    FailureCount     int64                       `json:"failure_count"`
    TopActors        []ActorStats                `json:"top_actors"`
    TopTargets       []TargetStats               `json:"top_targets"`
    EventTimeline    map[string]int64            `json:"event_timeline"` // Date -> count
}

type ActorStats struct {
    ActorID    string `json:"actor_id"`
    ActorName  string `json:"actor_name"`
    EventCount int64  `json:"event_count"`
}

type TargetStats struct {
    TargetType string `json:"target_type"`
    TargetID   string `json:"target_id"`
    EventCount int64  `json:"event_count"`
}
```

### Storage Backend Types

#### 1. JSON Audit Storage

```go
// JSONAuditStorage implements audit storage using JSON files
type JSONAuditStorage struct {
    filePath string
    mu       sync.RWMutex
    events   []*models.AuditEvent
}

// Features:
// - Single JSON file with array of events
// - Append-only for integrity
// - Rotation when file size exceeds threshold
// - In-memory cache for recent events
// - Periodic flush to disk
```

#### 2. MongoDB Audit Storage

```go
// MongoDBAuditStorage implements audit storage using MongoDB
type MongoDBAuditStorage struct {
    client     *mongo.Client
    database   *mongo.Database
    collection *mongo.Collection
}

// Features:
// - Dedicated audit collection
// - Indexes on timestamp, event_type, actor_id, target_id
// - TTL index for automatic retention
// - Aggregation pipeline for statistics
// - Efficient querying and filtering
```

### Configuration

```go
// AuditConfig holds audit logging configuration
type AuditConfig struct {
    Enabled      bool   `json:"enabled" bson:"enabled"`
    StorageType  string `json:"storage_type" bson:"storage_type"` // "json" or "mongodb"
    
    // JSON backend
    JSONFilePath     string `json:"json_file_path,omitempty" bson:"json_file_path,omitempty"`
    MaxFileSizeMB    int    `json:"max_file_size_mb,omitempty" bson:"max_file_size_mb,omitempty"`
    RotationEnabled  bool   `json:"rotation_enabled,omitempty" bson:"rotation_enabled,omitempty"`
    
    // MongoDB backend (can use same as main storage or separate)
    MongoURI         string `json:"mongo_uri,omitempty" bson:"mongo_uri,omitempty"`
    MongoDatabase    string `json:"mongo_database,omitempty" bson:"mongo_database,omitempty"`
    MongoCollection  string `json:"mongo_collection,omitempty" bson:"mongo_collection,omitempty"`
    
    // Retention
    RetentionDays    int    `json:"retention_days" bson:"retention_days"` // 0 = forever
    
    // Performance
    AsyncLogging     bool   `json:"async_logging" bson:"async_logging"`
    BufferSize       int    `json:"buffer_size" bson:"buffer_size"`
    FlushIntervalSec int    `json:"flush_interval_sec" bson:"flush_interval_sec"`
    
    // Privacy
    RedactSensitiveData bool `json:"redact_sensitive_data" bson:"redact_sensitive_data"`
}
```

---

## Implementation Tasks

### Phase 1: Core Audit Infrastructure (2 days)

#### Task 1.1: Create Audit Models
**File:** `backend/pkg/models/audit.go`

```go
package models

// Create AuditEvent, FieldChange, and related structs
// Add constants for categories, actions, actor types, severities
// Add helper methods for creating common audit events
```

#### Task 1.2: Create Audit Storage Interface
**File:** `backend/pkg/audit/storage.go`

```go
package audit

// Define AuditStorage interface
// Define AuditFilter, AuditStatistics structs
// Add storage factory function
```

#### Task 1.3: Implement JSON Audit Storage
**File:** `backend/pkg/audit/json_storage.go`

```go
package audit

type JSONAuditStorage struct {
    filePath string
    mu       sync.RWMutex
    buffer   []*models.AuditEvent
}

// Implement all AuditStorage interface methods
// Add file rotation logic
// Add buffering and flushing
// Add query filtering
```

#### Task 1.4: Implement MongoDB Audit Storage
**File:** `backend/pkg/audit/mongo_storage.go`

```go
package audit

type MongoDBAuditStorage struct {
    client     *mongo.Client
    database   *mongo.Database
    collection *mongo.Collection
}

// Implement all AuditStorage interface methods
// Create indexes
// Implement aggregation queries
// Add TTL index for retention
```

---

### Phase 2: Audit Middleware & Logger (2 days)

#### Task 2.1: Create Audit Logger Service
**File:** `backend/pkg/audit/logger.go`

```go
package audit

// AuditLogger provides high-level audit logging API
type AuditLogger struct {
    storage      AuditStorage
    config       *AuditConfig
    buffer       chan *models.AuditEvent
    hasher       hash.Hash
    systemActor  *models.Actor
}

// Methods for logging common events
func (al *AuditLogger) LogUserCreated(actor, target *models.User, details map[string]interface{}) error
func (al *AuditLogger) LogUserUpdated(actor *models.User, target *models.User, changes []models.FieldChange) error
func (al *AuditLogger) LogUserDeleted(actor *models.User, targetID string) error
func (al *AuditLogger) LogUserLogin(user *models.User, success bool, ip, userAgent string) error

func (al *AuditLogger) LogClientCreated(actor *models.User, client *models.Client) error
func (al *AuditLogger) LogClientUpdated(actor *models.User, client *models.Client, changes []models.FieldChange) error
func (al *AuditLogger) LogClientDeleted(actor *models.User, clientID string) error

func (al *AuditLogger) LogTokenIssued(client *models.Client, user *models.User, tokenType string) error
func (al *AuditLogger) LogTokenRevoked(actor *models.User, tokenID string, reason string) error

func (al *AuditLogger) LogSettingsUpdated(actor *models.User, changes []models.FieldChange) error
func (al *AuditLogger) LogKeysRotated(actor *models.User, oldKeyID, newKeyID string) error

// Generic method for custom events
func (al *AuditLogger) Log(event *models.AuditEvent) error

// Background worker for async logging
func (al *AuditLogger) Start() error
func (al *AuditLogger) Stop() error
```

#### Task 2.2: Create Audit Middleware
**File:** `backend/pkg/middleware/audit.go`

```go
package middleware

// AuditMiddleware logs HTTP requests that modify data
func AuditMiddleware(auditLogger *audit.AuditLogger) echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            // Skip GET requests (read-only)
            if c.Request().Method == "GET" || c.Request().Method == "OPTIONS" {
                return next(c)
            }
            
            // Capture request start time
            start := time.Now()
            
            // Extract actor from context (user or client)
            actor := extractActor(c)
            
            // Call next handler
            err := next(c)
            
            // Log audit event after request completes
            go logRequestAudit(auditLogger, c, actor, start, err)
            
            return err
        }
    }
}
```

---

### Phase 3: Integrate Audit Logging (2 days)

#### Task 3.1: Add Audit Logging to User Handlers
**File:** `backend/pkg/handlers/admin.go`

```go
// Example: CreateUser
func (h *AdminHandler) CreateUser(c echo.Context) error {
    // ... existing code to create user ...
    
    // Add audit logging
    actor := getActorFromContext(c)
    h.auditLogger.LogUserCreated(actor, newUser, map[string]interface{}{
        "ip_address": c.RealIP(),
        "user_agent": c.Request().UserAgent(),
    })
    
    return c.JSON(http.StatusCreated, response)
}

// Example: UpdateUser
func (h *AdminHandler) UpdateUser(c echo.Context) error {
    // ... get old user ...
    // ... update user ...
    
    // Calculate changes
    changes := calculateUserChanges(oldUser, updatedUser)
    
    // Add audit logging
    actor := getActorFromContext(c)
    h.auditLogger.LogUserUpdated(actor, updatedUser, changes)
    
    return c.JSON(http.StatusOK, updatedUser)
}

// Example: DeleteUser
func (h *AdminHandler) DeleteUser(c echo.Context) error {
    userID := c.Param("id")
    
    // ... get user for logging ...
    user, _ := h.store.GetUserByID(userID)
    
    // Delete user
    err := h.store.DeleteUser(userID)
    
    // Add audit logging
    actor := getActorFromContext(c)
    h.auditLogger.LogUserDeleted(actor, userID, map[string]interface{}{
        "username": user.Username,
        "email":    user.Email,
    })
    
    return c.NoContent(http.StatusNoContent)
}
```

#### Task 3.2: Add Audit Logging to Client Handlers
**File:** `backend/pkg/handlers/registration.go`

```go
// Add audit logging to Register, UpdateClientConfiguration, DeleteClientConfiguration
```

#### Task 3.3: Add Audit Logging to Token Handlers
**File:** `backend/pkg/handlers/token.go`

```go
// Add audit logging to token issuance, refresh, revocation
```

#### Task 3.4: Add Audit Logging to Settings Handlers
**File:** `backend/pkg/handlers/admin.go`

```go
// Add audit logging to settings updates, key rotation
```

#### Task 3.5: Add Audit Logging to Auth Handlers
**File:** `backend/pkg/handlers/handlers.go`

```go
// Add audit logging to login, logout, consent
```

---

### Phase 4: Admin UI for Audit Logs (2-3 days)

#### Task 4.1: Create Audit API Handlers
**File:** `backend/pkg/handlers/audit.go`

```go
package handlers

type AuditHandler struct {
    auditStorage audit.AuditStorage
    store        storage.Storage
}

// GetAuditEvents returns paginated audit events with filters
func (h *AuditHandler) GetAuditEvents(c echo.Context) error {
    // Parse query parameters
    filter := parseAuditFilter(c)
    
    // Get events from storage
    events, err := h.auditStorage.GetAuditEvents(filter)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to fetch audit events",
        })
    }
    
    // Get total count
    total, _ := h.auditStorage.CountAuditEvents(filter)
    
    return c.JSON(http.StatusOK, map[string]interface{}{
        "events": events,
        "total":  total,
        "offset": filter.Offset,
        "limit":  filter.Limit,
    })
}

// GetAuditEventByID returns a single audit event
func (h *AuditHandler) GetAuditEventByID(c echo.Context) error {
    id := c.Param("id")
    
    event, err := h.auditStorage.GetAuditEventByID(id)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "Audit event not found",
        })
    }
    
    return c.JSON(http.StatusOK, event)
}

// GetAuditStatistics returns aggregate statistics
func (h *AuditHandler) GetAuditStatistics(c echo.Context) error {
    from := parseTime(c.QueryParam("from"))
    to := parseTime(c.QueryParam("to"))
    
    stats, err := h.auditStorage.GetAuditStatistics(from, to)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to fetch statistics",
        })
    }
    
    return c.JSON(http.StatusOK, stats)
}

// ExportAuditEvents exports audit logs in various formats
func (h *AuditHandler) ExportAuditEvents(c echo.Context) error {
    filter := parseAuditFilter(c)
    format := c.QueryParam("format") // "json", "csv", "pdf"
    
    data, err := h.auditStorage.ExportAuditEvents(filter, format)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to export audit events",
        })
    }
    
    // Set appropriate headers
    c.Response().Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=audit-logs.%s", format))
    
    return c.Blob(http.StatusOK, getContentType(format), data)
}
```

#### Task 4.2: Add Audit Routes
**File:** `backend/cmd/serve.go`

```go
// Audit endpoints (admin only)
auditHandler := handlers.NewAuditHandler(auditStorage, store)
api.GET("/audit/events", auditHandler.GetAuditEvents)
api.GET("/audit/events/:id", auditHandler.GetAuditEventByID)
api.GET("/audit/statistics", auditHandler.GetAuditStatistics)
api.GET("/audit/export", auditHandler.ExportAuditEvents)
```

#### Task 4.3: Create Audit Logs Frontend Page
**File:** `frontend/src/pages/AuditLogs.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  TextField,
  Select,
  MenuItem,
  Button,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  Pagination,
} from '@mui/material';
import {
  FilterList,
  Download,
  Visibility,
  Refresh,
} from '@mui/icons-material';

interface AuditEvent {
  id: string;
  timestamp: string;
  event_type: string;
  category: string;
  action: string;
  actor_name: string;
  target_name: string;
  status: string;
  severity: string;
  ip_address?: string;
}

export default function AuditLogs() {
  const [events, setEvents] = useState<AuditEvent[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedEvent, setSelectedEvent] = useState<AuditEvent | null>(null);
  const [filters, setFilters] = useState({
    category: '',
    action: '',
    severity: '',
    searchText: '',
    fromDate: '',
    toDate: '',
  });
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);

  const fetchAuditEvents = async () => {
    setLoading(true);
    try {
      const queryParams = new URLSearchParams({
        offset: String((page - 1) * 50),
        limit: '50',
        ...filters,
      });
      
      const response = await fetch(`/api/admin/audit/events?${queryParams}`);
      const data = await response.json();
      
      setEvents(data.events);
      setTotalPages(Math.ceil(data.total / 50));
    } catch (error) {
      console.error('Failed to fetch audit events:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleExport = async (format: string) => {
    const queryParams = new URLSearchParams({ format, ...filters });
    window.open(`/api/admin/audit/export?${queryParams}`, '_blank');
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'critical': return 'error';
      case 'warning': return 'warning';
      default: return 'info';
    }
  };

  const getStatusColor = (status: string) => {
    return status === 'success' ? 'success' : 'error';
  };

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4" fontWeight="bold">
          Audit Logs
        </Typography>
        <Box display="flex" gap={1}>
          <Button
            startIcon={<Refresh />}
            onClick={fetchAuditEvents}
            variant="outlined"
          >
            Refresh
          </Button>
          <Button
            startIcon={<Download />}
            onClick={() => handleExport('csv')}
            variant="outlined"
          >
            Export CSV
          </Button>
          <Button
            startIcon={<Download />}
            onClick={() => handleExport('json')}
            variant="outlined"
          >
            Export JSON
          </Button>
        </Box>
      </Box>

      {/* Filters */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Box display="flex" gap={2} flexWrap="wrap">
          <TextField
            label="Search"
            value={filters.searchText}
            onChange={(e) => setFilters({ ...filters, searchText: e.target.value })}
            size="small"
            sx={{ minWidth: 200 }}
          />
          <Select
            value={filters.category}
            onChange={(e) => setFilters({ ...filters, category: e.target.value })}
            displayEmpty
            size="small"
            sx={{ minWidth: 150 }}
          >
            <MenuItem value="">All Categories</MenuItem>
            <MenuItem value="user">User</MenuItem>
            <MenuItem value="client">Client</MenuItem>
            <MenuItem value="token">Token</MenuItem>
            <MenuItem value="session">Session</MenuItem>
            <MenuItem value="settings">Settings</MenuItem>
          </Select>
          <Select
            value={filters.severity}
            onChange={(e) => setFilters({ ...filters, severity: e.target.value })}
            displayEmpty
            size="small"
            sx={{ minWidth: 150 }}
          >
            <MenuItem value="">All Severities</MenuItem>
            <MenuItem value="info">Info</MenuItem>
            <MenuItem value="warning">Warning</MenuItem>
            <MenuItem value="critical">Critical</MenuItem>
          </Select>
          <TextField
            label="From Date"
            type="datetime-local"
            value={filters.fromDate}
            onChange={(e) => setFilters({ ...filters, fromDate: e.target.value })}
            size="small"
            InputLabelProps={{ shrink: true }}
          />
          <TextField
            label="To Date"
            type="datetime-local"
            value={filters.toDate}
            onChange={(e) => setFilters({ ...filters, toDate: e.target.value })}
            size="small"
            InputLabelProps={{ shrink: true }}
          />
          <Button
            startIcon={<FilterList />}
            onClick={fetchAuditEvents}
            variant="contained"
          >
            Apply Filters
          </Button>
        </Box>
      </Paper>

      {/* Audit Events Table */}
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Timestamp</TableCell>
              <TableCell>Event Type</TableCell>
              <TableCell>Actor</TableCell>
              <TableCell>Target</TableCell>
              <TableCell>Status</TableCell>
              <TableCell>Severity</TableCell>
              <TableCell>IP Address</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {events.map((event) => (
              <TableRow key={event.id} hover>
                <TableCell>
                  {new Date(event.timestamp).toLocaleString()}
                </TableCell>
                <TableCell>
                  <Chip label={event.event_type} size="small" variant="outlined" />
                </TableCell>
                <TableCell>{event.actor_name}</TableCell>
                <TableCell>{event.target_name}</TableCell>
                <TableCell>
                  <Chip
                    label={event.status}
                    size="small"
                    color={getStatusColor(event.status)}
                  />
                </TableCell>
                <TableCell>
                  <Chip
                    label={event.severity}
                    size="small"
                    color={getSeverityColor(event.severity)}
                  />
                </TableCell>
                <TableCell>{event.ip_address || '-'}</TableCell>
                <TableCell>
                  <IconButton
                    size="small"
                    onClick={() => setSelectedEvent(event)}
                  >
                    <Visibility />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>

      <Box display="flex" justifyContent="center" mt={3}>
        <Pagination
          count={totalPages}
          page={page}
          onChange={(e, value) => setPage(value)}
          color="primary"
        />
      </Box>

      {/* Event Details Dialog */}
      <Dialog
        open={!!selectedEvent}
        onClose={() => setSelectedEvent(null)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Audit Event Details</DialogTitle>
        <DialogContent>
          {selectedEvent && (
            <Box>
              <pre style={{ whiteSpace: 'pre-wrap' }}>
                {JSON.stringify(selectedEvent, null, 2)}
              </pre>
            </Box>
          )}
        </DialogContent>
      </Dialog>
    </Box>
  );
}
```

#### Task 4.4: Add Audit Logs to Navigation
**File:** `frontend/src/components/Layout.tsx`

```tsx
// Add menu item for Audit Logs
<ListItem button component={Link} to="/audit-logs">
  <ListItemIcon>
    <HistoryIcon />
  </ListItemIcon>
  <ListItemText primary="Audit Logs" />
</ListItem>
```

---

### Phase 5: Testing & Documentation (1-2 days)

#### Task 5.1: Unit Tests
**File:** `backend/pkg/audit/logger_test.go`

Test cases:
- Audit event creation
- Field change calculation
- Hash generation and verification
- Filter query building
- Statistics aggregation

#### Task 5.2: Integration Tests
**File:** `backend/pkg/handlers/admin_test.go`

Test cases:
- Verify audit events created on user CRUD
- Verify audit events created on client CRUD
- Verify audit events created on token operations
- Verify audit events created on settings changes

#### Task 5.3: Performance Tests

Test cases:
- High-volume event logging (1000+ events/sec)
- Query performance with large datasets
- Export performance
- Memory usage during buffering

#### Task 5.4: Documentation
**File:** `docs/AUDIT_LOGGING.md`

Document:
- What events are audited
- Audit event structure
- How to query audit logs
- Retention policies
- Export formats
- Security considerations
- Compliance features

---

## Performance Considerations

### 1. Asynchronous Logging
- Log audit events asynchronously to avoid blocking request handlers
- Use buffered channels with configurable size
- Background worker flushes to storage periodically

### 2. Buffering Strategy
```go
// Buffer in memory, flush periodically or when buffer is full
const (
    DefaultBufferSize = 1000
    DefaultFlushInterval = 10 * time.Second
)
```

### 3. Storage Optimization

**JSON Storage:**
- Rotate files when they reach size threshold (e.g., 100MB)
- Compress old files
- Index recent events in memory

**MongoDB Storage:**
- Create indexes on frequently queried fields
- Use TTL indexes for automatic cleanup
- Use aggregation pipeline for statistics

### 4. Query Performance
- Implement pagination for all list endpoints
- Add caching for statistics
- Limit default query ranges (e.g., last 30 days)
- Add query timeouts

### 5. Data Volume Management
- Implement retention policies (delete events after N days)
- Archive old events to cold storage
- Compress exported data

---

## Security & Compliance

### 1. Tamper Detection
- Generate SHA-256 hash for each event
- Include previous event hash (blockchain-style)
- Verify hash chain on queries

```go
func (al *AuditLogger) calculateHash(event *models.AuditEvent, prevHash string) string {
    data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%s",
        event.Timestamp.Format(time.RFC3339Nano),
        event.EventType,
        event.ActorID,
        event.TargetID,
        event.Status,
        prevHash,
        event.ID,
    )
    hash := sha256.Sum256([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

### 2. Data Privacy
- Redact sensitive data (passwords, secrets)
- Comply with GDPR (right to be forgotten)
- Implement data minimization
- Pseudonymize when appropriate

```go
func (al *AuditLogger) redactSensitiveFields(details map[string]interface{}) {
    sensitiveFields := []string{"password", "secret", "token", "credit_card"}
    for _, field := range sensitiveFields {
        if _, exists := details[field]; exists {
            details[field] = "[REDACTED]"
        }
    }
}
```

### 3. Access Control
- Only admins can view audit logs
- Log audit log access (meta-auditing)
- Implement role-based access (e.g., security team vs. support team)

### 4. Compliance Features
- **GDPR**: Right to access, right to erasure
- **SOC 2**: Comprehensive logging, access controls
- **ISO 27001**: Security event logging
- **HIPAA**: Audit trail for healthcare data
- **PCI DSS**: Payment processing audit requirements

### 5. Immutability
- JSON storage: Append-only files
- MongoDB: Disable updates/deletes on audit collection
- Consider write-once-read-many (WORM) storage

---

## Timeline

| Phase | Tasks | Duration | Dependencies |
|-------|-------|----------|--------------|
| Phase 1 | Core infrastructure | 2 days | None |
| Phase 2 | Middleware & logger | 2 days | Phase 1 |
| Phase 3 | Integration | 2 days | Phase 2 |
| Phase 4 | Admin UI | 2-3 days | Phase 3 |
| Phase 5 | Testing & docs | 1-2 days | Phase 4 |
| **Total** | | **9-11 days** | |

---

## Success Criteria

1. âœ… All state-changing operations generate audit events
2. âœ… Audit events stored in separate storage (JSON or MongoDB)
3. âœ… Admin UI displays audit logs with filtering and search
4. âœ… Export functionality (CSV, JSON)
5. âœ… Statistics and visualizations available
6. âœ… Async logging doesn't impact request performance
7. âœ… Tamper detection implemented
8. âœ… Sensitive data redacted
9. âœ… Retention policies implemented
10. âœ… Comprehensive documentation
11. âœ… All tests passing

---

## Example Audit Events

### User Created
```json
{
  "id": "audit_123",
  "timestamp": "2025-10-24T10:30:00Z",
  "event_type": "user.created",
  "category": "user",
  "action": "created",
  "actor_type": "admin",
  "actor_id": "admin_1",
  "actor_name": "Admin User",
  "target_type": "user",
  "target_id": "user_456",
  "target_name": "john.doe",
  "status": "success",
  "severity": "info",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0...",
  "details": {
    "username": "john.doe",
    "email": "john@example.com",
    "role": "user"
  },
  "hash": "abc123..."
}
```

### Client Updated
```json
{
  "id": "audit_124",
  "timestamp": "2025-10-24T10:35:00Z",
  "event_type": "client.updated",
  "category": "client",
  "action": "updated",
  "actor_type": "admin",
  "actor_id": "admin_1",
  "actor_name": "Admin User",
  "target_type": "client",
  "target_id": "client_789",
  "target_name": "My App",
  "status": "success",
  "severity": "warning",
  "changes": [
    {
      "field": "redirect_uris",
      "old_value": ["https://old.example.com/callback"],
      "new_value": ["https://new.example.com/callback"]
    }
  ],
  "hash": "def456..."
}
```

### Failed Login
```json
{
  "id": "audit_125",
  "timestamp": "2025-10-24T10:40:00Z",
  "event_type": "user.login.failed",
  "category": "security",
  "action": "denied",
  "actor_type": "user",
  "actor_id": "unknown",
  "actor_name": "unknown_user",
  "target_type": "system",
  "target_id": "auth",
  "status": "failure",
  "severity": "warning",
  "ip_address": "192.168.1.200",
  "error_message": "Invalid credentials",
  "details": {
    "username": "attacker",
    "attempt_count": 5
  },
  "tags": ["security", "authentication", "failed_login"],
  "hash": "ghi789..."
}
```

---

## References

- [ISO 27001 - Audit Logging Requirements](https://www.iso.org/standard/54534.html)
- [SOC 2 - Security Logging Best Practices](https://www.aicpa.org/interestareas/frc/assuranceadvisoryservices/sorhome)
- [GDPR - Right to Access and Audit](https://gdpr-info.eu/)
- [NIST SP 800-92 - Guide to Computer Security Log Management](https://csrc.nist.gov/publications/detail/sp/800-92/final)
- [OWASP Logging Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html)
